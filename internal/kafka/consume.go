package kafka

import (
	"context"
	"encoding/json"
	"kafka-consumer/internal/database"
	"kafka-consumer/internal/models"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/IBM/sarama"
	"github.com/rs/zerolog/log"
)

type Consumer struct {
	group sarama.ConsumerGroup
	db    database.Service
}

func NewConsumer() (*Consumer, error) {
	var kafkaBootstrapServers string
	var brokers []string
	// Retry mechanism to get the environment variable
	for {
		kafkaBootstrapServers = os.Getenv("KAFKA_BOOTSTRAP_SERVERS")
		if kafkaBootstrapServers != "" {
			brokers = strings.Split(kafkaBootstrapServers, ",")
			break
		}
		log.Error().Msg("KAFKA_BOOTSTRAP_SERVERS environment variable is not set, retrying in 5 seconds...")
		time.Sleep(5 * time.Second)
	}

	config := sarama.NewConfig()
	config.Consumer.Return.Errors = true
	config.Consumer.Offsets.Initial = sarama.OffsetOldest
	config.Metadata.AllowAutoTopicCreation = false

	group, err := sarama.NewConsumerGroup(brokers, "cve-consumer", config)
	if err != nil {
		log.Error().Msgf("Failed to create consumer group: %v", err)
		return nil, err
	}

	return &Consumer{
		group: group,
		db:    database.New(),
	}, nil
}

func (c *Consumer) ConsumeMessages(wg *sync.WaitGroup) {
	defer wg.Done()
	handler := consumerGroupHandler{
		db: c.db,
	}

	ctx := context.Background()
	for {
		err := c.group.Consume(ctx, []string{os.Getenv("KAFKA_TOPIC")}, handler)
		if err != nil {
			log.Error().Msgf("Error from consumer: %v", err)
		}
	}
}

type consumerGroupHandler struct {
	db database.Service
}

// Setup is run at the beginning of a new session, before ConsumeClaim.
func (h consumerGroupHandler) Setup(_ sarama.ConsumerGroupSession) error {
	log.Info().Msg("Consumer group session set up")
	return nil
}

// Cleanup is run at the end of a session, once all ConsumeClaim goroutines have exited.
func (h consumerGroupHandler) Cleanup(_ sarama.ConsumerGroupSession) error {
	log.Info().Msg("Consumer group session cleaned up")
	return nil
}

// ConsumeClaim must start a consumer loop of ConsumerGroupClaim's Messages().
func (h consumerGroupHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	for msg := range claim.Messages() {
		var data models.CveRecord
		err := json.Unmarshal(msg.Value, &data)
		if err != nil {
			log.Error().Msgf("Failed to unmarshal message value: %v", err)
			continue
		}

		// Insert the message into the database
		err = h.db.InsertCVE(data.CveMetadata.CveID, data.CveMetadata.DatePublished, data.CveMetadata.DateUpdated, msg.Value)
		if err != nil {
			log.Error().Msgf("Failed to insert CVE: %v", err)
		}

		log.Info().Msgf("Message claimed: timestamp = %v, topic = %v", msg.Timestamp, msg.Topic)

		// Mark message as processed
		sess.MarkMessage(msg, "")
	}
	return nil
}

func (c *Consumer) Close() {
	c.group.Close()
}
