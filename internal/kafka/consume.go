package kafka

import (
	"encoding/json"
	"kafka-consumer/internal/database"
	"kafka-consumer/internal/models"
	"os"
	"time"

	"github.com/confluentinc/confluent-kafka-go/kafka"
	"github.com/rs/zerolog/log"
)

// Consumer struct
type Consumer struct {
	consumer *kafka.Consumer
	db       database.Service
}

// NewConsumer initializes and returns a new Kafka consumer
func NewConsumer() (*Consumer, error) {
	consumer, err := kafka.NewConsumer(getConsumerConfig())
	if err != nil {
		log.Error().Msgf("Failed to create consumer: %v", err)
		return nil, err
	}

	topic := os.Getenv("KAFKA_TOPIC")
	// TODO: use rebalanceCB to handle rebalancing
	err = consumer.Subscribe(topic, nil)
	if err != nil {
		log.Error().Msgf("Failed to subscribe to topic: %v", err)
		return nil, err
	}

	return &Consumer{
		consumer: consumer,
		db:       database.New(),
	}, nil
}

// TODO: Use environment variables for Kafka configuration
func getConsumerConfig() *kafka.ConfigMap {
	return &kafka.ConfigMap{
		"bootstrap.servers": os.Getenv("KAFKA_BOOTSTRAP_SERVERS"),
		"group.id":          os.Getenv("KAFKA_GROUP_ID"),
		"auto.offset.reset": os.Getenv("KAFKA_AUTO_OFFSET_RESET"),
	}
}

// ReadMessage reads a message from the Kafka topic
func (c *Consumer) ReadMessage(timeout time.Duration) (*kafka.Message, error) {
	return c.consumer.ReadMessage(timeout)
}

func (c *Consumer) ConsumeMessages() {
	log.Info().Msg("Starting Kafka Consumer")
	const numWorkers = 2 // Number of workers in the pool
	messages := make(chan *kafka.Message, numWorkers)

	// Start the worker pool
	for i := 0; i < numWorkers; i++ {
		go func() {
			for message := range messages {
				var data models.CveRecord
				err := json.Unmarshal(message.Value, &data)
				if err != nil {
					log.Error().Msgf("Failed to unmarshal message value: %v", err)
					continue
				}

				// Insert the message into the database
				err = c.db.InsertCVE(data.CveMetadata.CveID, data.CveMetadata.DatePublished, data.CveMetadata.DateUpdated, message.Value)
				if err != nil {
					log.Error().Msgf("Failed to insert CVE: %v", err)
				}
			}
		}()
	}

	for {
		// Poll for a message
		msg, err := c.consumer.ReadMessage(100 * time.Millisecond)
		if err == nil {
			log.Info().Msg("Message received")
			// Send the message data to the worker pool
			messages <- msg

		} else if err.(kafka.Error).Code() != kafka.ErrTimedOut {
			log.Error().Msgf("Consumer error: %v (%v)", err, msg)
		}
	}
}

// Close closes the Kafka consumer
func (c *Consumer) Close() {
	c.consumer.Close()
}
